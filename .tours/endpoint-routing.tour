{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Endpoint Routing",
  "steps": [
    {
      "file": "src/Http/samples/MinimalSample/Program.cs",
      "description": "We'll start by looking at `WebApplicationBuilder` and `WebApplication` which make up the new host introduced in ASP.NET Core 6.",
      "line": 10
    },
    {
      "file": "src/DefaultBuilder/src/WebApplicationBuilder.cs",
      "description": "`WebApplication` adds routing and endpoint [middleware](https://learn.microsoft.com/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#create-a-middleware-pipeline-with-webapplication) automatically on your behalf if you do not call [`app.UseRouting()`](https://learn.microsoft.com/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting?view=aspnetcore-7.0) and/or [`app.UseEndopints()`](https://learn.microsoft.com/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.useendpoints?view=aspnetcore-7.0) manually.",
      "line": 165
    },
    {
      "file": "src/DefaultBuilder/src/WebApplicationBuilder.cs",
      "description": "The endpoint middleware is added to the end of the pipeline to allow other middleware like auth middleware to examine the endpoint matched by routing and take action before running the primary application logic for the endpoint.",
      "line": 210
    },
    {
      "file": "src/DefaultBuilder/src/WebApplicationBuilder.cs",
      "description": "And this is where custom added middlware gets added to the middle of the middlware pipeline.",
      "line": 203
    },
    {
      "file": "src/DefaultBuilder/src/WebApplication.cs",
      "description": "`WebApplication` is not availabe as a service. The service provider has alrady been created, but it does make itself available to endpoint routing middleware via `((IApplicationBuilder)app).Properties[\"__GlobalEndpointRouteBuilder\"]`.",
      "line": 33
    },
    {
      "file": "src/Http/Routing/src/Builder/EndpointRoutingApplicationBuilderExtensions.cs",
      "description": "We access the `WebApplication` object using the `\"__GlobalEndpointRouteBuilder\"` key in `UseRouting()`. `WebApplication` is passed into the `EndpointRoutingMiddleware` constructor as an `IEndpointRouteBuilder` here in so the middleware can match the routes. `IEndpointRouteBuilder` is the target for \"Map\" methods like `MapGet`, `MapPost` and the new `MapGroup`. ",
      "line": 48
    },
    {
      "file": "src/Http/Routing/src/EndpointRoutingMiddleware.cs",
      "description": "Endpoint initialization is delayed until the first request hits the `EndpointRoutingMiddleware`. This means errors during endpoint generation do not surface until then.",
      "line": 61
    },
    {
      "file": "src/Http/Routing/src/Matching/DfaMatcher.cs",
      "description": "If `EndpointRoutingMiddleware` determines the request matches a defined endpoint, it sets the `Endpoint` on the `HttpContext`.",
      "line": 78
    },
    {
      "file": "src/Http/Routing/src/EndpointRoutingMiddleware.cs",
      "description": "Match or no match, `EndpointRoutingMiddleware` continues the middleware pipeline to give other middleware the chance to inspect the `Endpoint` before executing the main app logic associated with it.",
      "line": 110
    },
    {
      "file": "src/Http/Routing/src/EndpointMiddleware.cs",
      "description": "If the request makes it all the way to the `EndpointMiddleware` at the end of the pipeline, it executes the `RequestDelegate` defined by `httpContext.GetEndpoint()`.",
      "line": 57
    },
    {
      "file": "src/Http/Http.Abstractions/src/Routing/Endpoint.cs",
      "description": "This is an `Endpoint` by the way. It really is just these three properties.\r\n\r\n1. The `RequestDelegate` is a `Func<HttpContext, Task>` which basically terminal middleware handling the application logic of the endpoint. This invokes the `MapGet` route handler, MVC controller etc...\r\n2. The `Metadata` is an `IReadOnly<object>` containing metadata about the endpoint like its attributes (e.g. `[Authorize]`) and what HTTP verbs to accept (e.g. GET).\r\n3. The `DisplayName` helpful name for debugging.",
      "line": 24
    },
    {
      "file": "src/Http/Routing/src/RouteEndpoint.cs",
      "description": "You might have noticed that `Endpoint` is missing a `RoutePattern` to match against. That's in the derived class, `RouteEndpoint`.\r\n\r\nIt includes an `Order` too, but it's usually left at 0. If a request matches multiple endpoints with the same `Order` value, matching will fail.",
      "line": 29
    },
    {
      "file": "src/Http/Routing/src/Builder/EndpointRouteBuilderExtensions.cs",
      "description": "`Endpoint` instances are registered to the `WebApplication` via `IEndpointRouteBuilder.DataSources` which is an `ICollection<EndopintDataSource>`.",
      "line": 430
    },
    {
      "file": "src/Http/Routing/src/EndpointDataSource.cs",
      "description": "At its core, `EndpointDataSource` is an `IReadOnlyList<Endpoint>` with a change token. Yes. This does mean that endpoints can change at any time!\r\n\r\nDon't pay too much attention to `GetGroupedEndpoints` yet. That's new in .NET 7, and we'll get to that later.",
      "line": 26
    },
    {
      "file": "src/Http/Routing/src/RouteEndpointDataSource.cs",
      "description": "Route handlers are provided via the `RouteEndopintDataSource`. Every time a \"Map\" method is called, it adds an item to a `_routeEntries`.",
      "line": 72
    },
    {
      "file": "src/Http/Routing/src/RouteEndpointDataSource.cs",
      "description": "The \"Map\" methods then return a which is an `IEndpointConventionBuilder`. This is the target for extension methods like `RequireAuthorization`, `RequireRateLimiting`, `CacheOutput` and `WithMetadata`.",
      "line": 74
    },
    {
      "file": "src/Http/Routing/src/RouteEndpointDataSource.cs",
      "description": "`RouteEndopintBuilder.Endpoints` iterates over each item in `_routeEntries` and builds a `RouteEndpoint` from a `RouteEndpointBuilder` while applying conventions.",
      "line": 84
    },
    {
      "file": "src/Http/Http.Abstractions/src/Extensions/IEndpointConventionBuilder.cs",
      "description": "This is the `IEndpointConventionBuilder` interface. The interface has been arround since 3.0, but the `Finally` method is new in .NET 7. This was made possible thanks to default interface methods which were introduced in C# 8.\r\n\r\nWe'll get into why the `Finally` method is useful in a little bit, but for now notice that this interface asks for an `Action<EndpointBuilder>` rather than exposing an `EndpointBuilder` directly. This was important for making `IEndpointConventionBuilder` extension methods work with `MapGroup` which allows adding \"conventions\" to multiple endpoints at once.",
      "line": 25
    },
    {
      "file": "src/Http/Routing/src/RouteEndpointDataSource.cs",
      "description": "When creating endpoints, RouteEndpointDataSource add metadata in the following order\r\n\r\n1. `MethodInfo` (for `Delegates` not `RequestDelegate`)\r\n2. `HttpMethodMetadata` (for `MapXXX` not just `Map` which accepts all HTTP verbs)\r\n3. `RequestDelegateFactory.InferMetadata()` potentially adds:\r\n   1. `AcceptsMetadata`\r\n   2. `ProducesMetadata`\r\n   3. Static interface metadata providers\r\n4. Group conventions (outer to inner)\r\n5. Attributes\r\n6. Route-specific conventions\r\n7. Route-specific finally conventions\r\n8. Group finally conventions (inner to outer)\r\n\r\nThat's a lot of metadata! There are so many steps in order to enable the later conventions, \"finally\" and \"group finally\" conventions in particular to observe metadata added to a specific route entry. And we want all conventions to be able to observer inferred metadata.\r\n\r\nHistorically, metadata has mostly been read by middleware during the request. But with the introduction of group conventions and `WithOpenApi` in particular, it has become useful to observe route-specific metadata during endpoint creation.",
      "line": 248
    },
    {
      "file": "src/Http/Routing/src/RouteGroupBuilder.cs",
      "description": " [`app.MapGroup(prefix)`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mapgroup?view=aspnetcore-7.0) simply passes both of its parameteters to this `RouteGroupBuilder` constructor and returns it. `RouteGroupBuilder` impelements both `IEndpointRouteBuilder` and `IEndpointConventionBuilder` so child routes can be defined without repeating a common prefix or conventions.\r\n\r\n`RouteGroupBuilder` uses the internal `GroupEndpointDataSource` to do it's magic. This wraps inner `EndpointDataSource` instances added by methods such as `MapGet` and `MapControllerRoute` when they're called on group. When ASP.NET Core resolves endpoints from the `GroupEndpointDataSource` in the `EndpointRoutingMiddleware`, it prepends the given prefix to each `RouteEndpoint` and applies all the conventions applied to the `RouteGroupBuilder` to each endpoint in the group.\r\n\r\n**NOTE:** The prefix can be empty and/or shared between multiple groups!",
      "line": 31
    },
    {
      "file": "src/Http/Routing/src/RouteGroupBuilder.cs",
      "description": "The outer group's conventions are added before the inner group's conventions, but the outer groups `Finally` convention's run after the inner groups `Finally` conventions.\r\n\r\nThis ensures that normal non-group aware conventions don't accidently clobber endpoint-specific conventions. Finally conventionsa are most uesful when you want group conventions to enhance endpoint-specefic conventions.",
      "line": 97
    },
    {
      "file": "src/Http/Routing/src/EndpointDataSource.cs",
      "description": "Since `EndpointDataSource.GetGroupedEndopints` is new, it has a default implementation. It creates a `RouteEndopintBuilder` from `this.Endpoints`, and then runs group conventions. This works fairly well, but it means that `EndpointDataSource` implementations that don't override this method cannot expose inferred metadata to normal group conventions. All metadata is still visible to `Finally` conventions.",
      "line": 67
    },
    {
      "file": "src/Http/Routing/src/DependencyInjection/RoutingServiceCollectionExtensions.cs",
      "description": "If you want to access a global list of endpoints, you can resolve the root `CompositeEndpointDataSource` as an `EndpointDataSource` from DI. `CompositeEndopintDataSource` basically does a `SelectMany` on the endpoints of all the child `EndpointDataSources` added to `WebApplication` or the `UseEndpoints` callback.",
      "line": 64
    }
  ],
  "ref": "v7.0.0-rc.1.22427.2"
}